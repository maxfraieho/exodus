---
{"title":"3 сервіси","dg-publish":true,"dg-metatags":null,"dg-home":null,"permalink":"/dokumentacziya-proektu/3-servisi/","dgPassFrontmatter":true,"noteIcon":""}
---


Ось розбиття вашого `docker-compose.yml` на три файли згідно з вимогами. Кожен файл містить власний `cloudflared` та мережу `exodus-net`:

### 1. `qwen.yaml` (перший файл)
```yaml
version: '3.8'

services:
  qwen:
    image: ghcr.io/abetlen/llama-cpp-python:latest
    container_name: qwen
    restart: unless-stopped
    ports:
      - "8081:8000"
    environment:
      - MODEL=/models/Qwen2_1_5b_instruct.Q4_K_M.gguf
      - N_CTX=8192
      - N_THREADS=4
    volumes:
      - ./models:/models
    networks:
      - exodus-net

  cloudflared:
    image: cloudflare/cloudflared
    container_name: cloudflared-qwen
    restart: unless-stopped
    volumes:
      - ./cloudflared-qwen:/etc/cloudflared
    command: tunnel run exodus-tunnel
    networks:
      - exodus-net

networks:
  exodus-net:
    external: true
```

### 2. `chromadb.yaml` (другий файл)
```yaml
version: '3.8'

services:
  chromadb:
    image: chromadb/chroma:latest
    container_name: chromadb
    ports:
      - "8000:8000"
    environment:
      - CHROMA_SERVER_HOST=0.0.0.0
      - CHROMA_SERVER_PORT=8000
    volumes:
      - ./chroma_data:/chroma/.chroma
    restart: unless-stopped
    networks:
      - exodus-net

  ts-app:
    image: ts-app:latest
    container_name: ts-app
    restart: unless-stopped
    init: true
    ports:
      - "3000:3000"
    environment:
      CHROMADB_URL: http://chromadb:8000
    depends_on:
      chromadb:
        condition: service_started
    networks:
      - exodus-net

  cloudflared:
    image: cloudflare/cloudflared
    container_name: cloudflared-chromadb
    restart: unless-stopped
    volumes:
      - ./cloudflared-chromadb:/etc/cloudflared
    command: tunnel run exodus-tunnel
    networks:
      - exodus-net

networks:
  exodus-net:
    external: true
```

### 3. `main.yaml` (третій файл)
```yaml
version: '3.8'

services:
  portainer:
    image: portainer/portainer-ce:latest
    container_name: portainer
    restart: unless-stopped
    ports:
      - "9000:9000"
      - "9443:9443"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer_data:/data
    networks:
      - exodus-net

  minio:
    image: minio/minio:latest
    container_name: minio
    ports:
      - "9100:9000"
      - "9001:9001"
    environment:
      - MINIO_ROOT_USER=vokov
      - MINIO_ROOT_PASSWORD=805235io
    volumes:
      - ./minio-data:/data
    command: server /data --console-address ":9001"
    restart: unless-stopped
    networks:
      - exodus-net
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  cloudflared:
    image: cloudflare/cloudflared
    container_name: cloudflared-main
    restart: unless-stopped
    volumes:
      - ./cloudflared-main:/etc/cloudflared
    command: tunnel run exodus-tunnel
    networks:
      - exodus-net

volumes:
  portainer_data:

networks:
  exodus-net:
    external: true
```

### Важливі зауваження:
1. **Унікальні імена контейнерів**:
   - Кожен `cloudflared` має унікальне `container_name`:
     - `cloudflared-qwen`
     - `cloudflared-chromadb`
     - `cloudflared-main`

2. **Ізольовані конфігурації Cloudflare**:
   - Для кожного `cloudflared` створено окрему директорію:
     - `./cloudflared-qwen`
     - `./cloudflared-chromadb`
     - `./cloudflared-main`
   - *Переконайтесь, що ці директорії існують та містять відповідні TLS-сертифікати*

3. **Мережа**:
   - Мережа `exodus-net` має бути створена зовнішньо перед запуском:
     ```bash
     docker network create exodus-net
     ```

4. **Запуск сервісів**:
   - Запускайте файли окремо:
     ```bash
     docker-compose -f qwen.yaml up -d
     docker-compose -f chromadb.yaml up -d
     docker-compose -f main.yaml up -d
     ```

5. **Залежності сервісів**:
   - Сервіс `ts-app` чекає на готовність `chromadb` через `depends_on`
   - Для `minio` додано healthcheck для перевірки готовності

Ця структура дозволяє керувати групами сервісів незалежно, зберігаючи кожен `cloudflared` із власним тунелем у відповідному файлі.